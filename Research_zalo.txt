- V·ªõi web th√¨ d√≤ websocket -> h√†m open websocket -> ra listener message -> d√≤ ra _onRawData -> _onData ƒë·ªÉ x·ª≠ l√Ω message sau khi ƒë√£ decrypt v√† h√†m decrypt -> ƒë∆∞a v√†o chatgpt ƒë·ªÉ generate ra code decrypt v·ªõi key ƒë∆∞·ª£c t·∫°o ra ·ªü m·ªói session

- V·ªõi zalo window app th√¨ n√≥ ƒëang ƒë∆∞·ª£c build b·∫±ng electron -> web-based app -> unpackaged ra ƒë·∫∑t t√™n folder l√† app, move app.asar qua ch·ªó kh√°c, t·∫°o 1 file app.asar kh√°c v·ªõi n·ªôi dung l√† :echo "{}" -> ƒë·ªÉ n√≥ fallback v·ªÅ folder app (do trong logic c·ªßa Zalo.exe s·∫Ω check xem app.asar c√≥ hay kh√¥ng) -> sau ƒë√≥ x√†i JS-Beautify for VS Code extension (·∫•n F1 -> beautify) ƒë·ªÉ generate ra code d·ªÖ ƒë·ªçc h∆°n

- Flow t√¨m th√¨ t·ª´ vi·ªác open WebSocket -> d√≤ ra c√°c listener li√™n quan -> d√≤ ra h√†m s·ª≠ d·ª•ng ƒë·ªÉ decrypt

- H√†m x·ª≠ l√Ω undo trong database v√† tin nh·∫Øn m·ªõi nh·∫≠n t·ªõi

- beautify b·∫±ng js-beautify : Get-ChildItem .\ -Recurse -Filter *.js | ForEach-Object { js-beautify $_.FullName -r }

- replace b·∫±ng git grep: git grep -l 'devTools: !1' | xargs sed -i 's/devTools: !1/devTools: true/g'

- debug UI electron: Zalo.exe --remote-debugging-port=9222
- debug main.js electron : Zalo.exe --inspect=9229
-> Zalo.exe --inspect=9229 --remote-debugging-port=9222
edge://inspect/#devices
chrome://inspect/#devices

- ƒëem console.log v·ªÅ:
	const iframe = document.createElement('iframe');
	iframe.style.display = 'none';
	document.body.appendChild(iframe);

	// G√°n l·∫°i console.log t·ª´ iframe
	console.log = iframe.contentWindow.console.log.bind(window);

- string to json: JSON.parse()

- H√†m IIFE search full path t·ªõi `this` (t·∫°o scope ri√™ng): (nh·∫≠p v√†o console)
	(() => {
		const target = this._onData;

		const deepTrace = (obj, path = "window", visited = new WeakSet()) => {
			if (visited.has(obj)) return;
			visited.add(obj);

			for (let key in obj) {
				try {
					const val = obj[key];
					const fullPath = `${path}.${key}`;
					if (val === target) {
						console.log("üîç Found at", fullPath);
					} else if (typeof val === "object" && val !== null) {
						deepTrace(val, fullPath, visited);
					}
				} catch (e) {}
			}
		};

		deepTrace(window);
	})();

- V·ªõi zalo pc th√¨ patch nh∆∞ n√†y:
	default-login-main-startup-shared-worker-znotification.b65af72f3439d0f838c9.js:
	async _onData(e, t, n, a) {
		let tmp = JSON.parse(a);
		if (tmp?.data?.msgs?.[0]?.msgType === "chat.undo") {
			tmp.data.msgs[0].msgType = "chat.undo_fake";
			a = JSON.stringify(tmp);
		}
		const s = this._getDataHanlder(e, t);
		if (!s) return void this._submitSentry("unsupported cmd " + e);
		let i = null;
		try {
			i = s.preParseData(a)
		} catch (o) {
			return this._submitSentry("error on parsing data " + o), void this._onDataError(_.c.CANNOT_PARSE)
		}
		0 === i.error_code ? s.onData(e, t, i) : this._onDataError(i.error_code)
	}

Tampermonkey script:
https://github.com/Tampermonkey/tampermonkey/issues/2384
	- Send to telegram:
		// ==UserScript==
		// @name         Zalo to Telegram
		// @namespace    http://tampermonkey.net/
		// @version      1.0
		// @description  G·ª≠i tin nh·∫Øn t·ª´ Zalo sang Telegram
		// @match        https://chat.zalo.me/*
		// @grant        GM_xmlhttpRequest
		// @grant        unsafeWindow
		// @connect      api.telegram.org
		// @sandbox     JavaScript
		// ==/UserScript==

		(function() {
			'use strict';

			const BOT_TOKEN = "";
			const CHAT_ID = "";

			window.addEventListener("message", function(event) {
				if (event.data?.type === "ZALO_DATA") {
					const a = event.data.payload;
					const content = a?.data?.msgs?.[0]?.content || "[Kh√¥ng c√≥ n·ªôi dung]";
					const sender = a?.data?.msgs?.[0]?.dName || "Unknown";

					const text = `üí¨ Tin nh·∫Øn t·ª´ ${sender}:\n${content}`;

					GM_xmlhttpRequest({
						method: "POST",
						url: `https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`,
						headers: {
							"Content-Type": "application/x-www-form-urlencoded"
						},
						data: `chat_id=${CHAT_ID}&text=${encodeURIComponent(text)}`,
						onload: function(response) {
							console.log("‚úÖ G·ª≠i Telegram:", response.responseText);
						},
						onerror: function(err) {
							console.error("‚ùå L·ªói g·ª≠i:", err);
						}
					});

				}
			});
		})();

	- Patch chat.zalo.me ch·∫∑n undo v√† g·ªüi message t·ªõi tele:
		// ==UserScript==
		// @name         New 2
		// @namespace    http://tampermonkey.net/
		// @version      2025-09-12
		// @description  try to take over the world!
		// @author       You
		// @match        https://chat.zalo.me/*
		// @run-at       document-start
		// @icon         data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==
		// @grant        none
		// ==/UserScript==

		(function() {
			'use strict';

			// Kh√¥i ph·ª•c console.log g·ªëc ƒë·ªÉ tr√°nh b·ªã web override
			const iframe = document.createElement('iframe');
			document.body.appendChild(iframe);
			console.log = iframe.contentWindow.console.log.bind(window.console);


			function restoreConsole() {
				const iframe = document.createElement('iframe');
				document.body.appendChild(iframe);
				console.log = iframe.contentWindow.console.log.bind(window.console);
			}

			function hookSocket(socketObj) {
				if (!socketObj || typeof socketObj._onData !== 'function') return;
				console.log("üéØ Hooking _onData on", socketObj);

				const orig = socketObj._onData;
				socketObj._onData = function(e, t, n, a) {
					console.log("a =", a);
					try {
						let parsed = a;
						let isString = false;

						if (typeof a === "string") {
							parsed = JSON.parse(a);
							isString = true;
						}
						//if (typeof a === "string") parsed = JSON.parse(a);

						if (
							parsed?.data?.msgs &&
							parsed.data.msgs.some(msg => msg.msgType === "chat.undo")
						) {
							console.log("‚è© B·ªè qua x·ª≠ l√Ω v√¨ msgType = chat.undo");
							parsed.data.msgs[0].msgType = "chat.undo_fake";

							// G·ª≠i n·ªôi dung ra ngo√†i qua postMessage
							window.postMessage({
								type: "ZALO_DATA",
								payload: parsed
							}, "*");

							// N·∫øu ban ƒë·∫ßu l√† string ‚Üí stringify l·∫°i ƒë·ªÉ thay th·∫ø trong a
							if (isString) {
								a = JSON.stringify(parsed);
							} else {
								a = parsed;
							}

							return orig.apply(this, [e, t, n, a]); // Kh√¥ng g·ªçi h√†m g·ªëc
						}
					} catch (err) {
						console.warn("L·ªói khi check a:", err);
					}
					return orig.apply(this, [e, t, n, a]);
				};
			}

			// ƒê·ª£i t·ªõi khi object xu·∫•t hi·ªán r·ªìi hook
			function waitForSocket() {
				const target = window.$$afmc?.socketPolling?._chatHandler?._socket;
				if (target && typeof target._onData === 'function') {
					hookSocket(target);
				} else {
					setTimeout(waitForSocket, 50);
				}
			}

			waitForSocket();



		})();

- Ph∆∞∆°ng ph√°p m√† zalo decrypt key:
	from base64 import b64decode
	from Crypto.Cipher import AES
	import gzip
	from io import BytesIO

	def b64_to_bytes(s: str) -> bytes:
		"""Chuy·ªÉn ƒë·ªïi chu·ªói Base64 sang bytes."""
		return b64decode(s)

	def decrypt_aes_128_gcm(base64_data: str, key: bytes) -> bytes:
		"""Gi·∫£i m√£ d·ªØ li·ªáu b·∫±ng AES-128-GCM."""
		raw = b64_to_bytes(base64_data)
		iv = raw[:16]
		aad = raw[16:32]
		ciphertext = raw[32:-16]
		tag = raw[-16:]

		cipher = AES.new(key, AES.MODE_GCM, nonce=iv)
		cipher.update(aad)
		plaintext = cipher.decrypt_and_verify(ciphertext, tag)
		return plaintext

	def decrypt_and_decompress(enc_base64: str, key_base64: str) -> str:
		"""Gi·∫£i m√£ v√† gi·∫£i n√©n d·ªØ li·ªáu t·ª´ Zalo WebSocket."""
		try:
			key = b64_to_bytes(key_base64)
			decrypted_bytes = decrypt_aes_128_gcm(enc_base64, key)
			with gzip.GzipFile(fileobj=BytesIO(decrypted_bytes)) as f:
				decompressed = f.read()
			return decompressed.decode('utf-8')
		except Exception as e:
			return f"‚ùå Decrypt failed: {e}"

	# === V√≠ d·ª• s·ª≠ d·ª•ng ===
	if __name__ == "__main__":
		key_base64 = 's5UdtUr2zLeLFPEe5IKUHw=='
		enc_base64 = 'FPRBtuqciMaFEm7DQ2dGq1uMugkqNe6B60zYc98ZFb/6YzLvOTeJFxldbKKtkUtmQuKYZ4hS1r0fxmaw1riS8Z8ZwAx/c3G1lRY/YPc5r0tlpsGUyNIPgoLT6Ecl2yWg5506zX1Dmhmn67Uj5BqlUubjDnN9WdtoAnlwt3RGGeV7btBWhkKTgkkzzbJgbrdu58eGJlBJregkNpPA8238/4jTJhYvLZLLKK99VoCrkkQT36doPyWGUKt18XWoVPanDBuSCkVW7/09c7wILpvVYDCIfhnJHBN4i/v8zQGhOnqCyNYk1amfEVA52+N3WSEPojtp/nObep4='

		result = decrypt_and_decompress(enc_base64, key_base64)
		print("‚úÖ Final content:", result)

- k·∫øt h·ª£p v·ªõi mitm ƒë·ªÉ xem log realtime:
	from mitmproxy import ctx, http
	from base64 import b64decode
	from Crypto.Cipher import AES
	import gzip
	from io import BytesIO
	import json

	# Bi·∫øn to√†n c·ª•c ƒë·ªÉ l∆∞u tr·ªØ key gi·∫£i m√£
	_cipher_key = None

	def websocket_message(flow: http.HTTPFlow):
		# Ch·ªâ x·ª≠ l√Ω n·∫øu flow n√†y l√† WebSocket
		if flow.websocket is None:
			return

		# L·∫•y tin nh·∫Øn cu·ªëi c√πng
		msg = flow.websocket.messages[-1]
		direction = "Client ‚Üí Server" if msg.from_client else "Server ‚Üí Client"

		try:
			# Th·ª≠ decode tin nh·∫Øn th√†nh vƒÉn b·∫£n
			text = msg.content.decode("utf-8", errors="replace")
			
			# Convert to json
			json_start = msg.content.find(b'{')
			json_bytes = msg.content[json_start:]
			json_str = json_bytes.decode('utf-8')
			data = json.loads(json_str)

			global _cipher_key

			# C·∫≠p nh·∫≠t key n·∫øu c√≥
			if "key" in data:
				_cipher_key = data["key"]
				ctx.log.info(f"[WS] Key updated: {data['key']}")

			# N·∫øu c√≥ d·ªØ li·ªáu m√£ h√≥a, ti·∫øn h√†nh gi·∫£i m√£ v√† gi·∫£i n√©n
			if "data" in data and _cipher_key:
				encrypted_data = data["data"]
				try:
					decrypted_content = decrypt_and_decompress(encrypted_data, _cipher_key)
					ctx.log.info(f"[WS] {direction} | Decrypted Data: {decrypted_content}")
				except Exception as e:
					ctx.log.error(f"[WS] {direction} | Decrypt failed: {e}")
					
		except json.JSONDecodeError:
			# N·∫øu kh√¥ng ph·∫£i JSON, in ra n·ªôi dung th√¥
			ctx.log.info("=====DEBUG-NOTHING=====")
			# Th·ª≠ decode tin nh·∫Øn th√†nh vƒÉn b·∫£n
			text = msg.content.decode("utf-8", errors="replace")
			json_start = msg.content.find(b'{')
			json_bytes = msg.content[json_start:]
			json_str = json_bytes.decode('utf-8')
			data = json.loads(json_str)
			# Th·ª≠ parse JSON
			#data = json.loads(text)
			ctx.log.info("v=====DEBUG=====")
			ctx.log.info(f"Received message content: {repr(data)}")
			ctx.log.info("^=====DEBUG=====")
			#ctx.log.info(f"[DEBUG] {direction}: {repr(msg.content.data)}")
			ctx.log.info(f"[WS] {direction}: {repr(msg.content)}")
		except Exception as e:
			ctx.log.error(f"[WS] {direction} | Unexpected error: {e}")

	def b64_to_bytes(s: str) -> bytes:
		"""Chuy·ªÉn ƒë·ªïi chu·ªói Base64 sang bytes."""
		return b64decode(s)

	def decrypt_aes_128_gcm(base64_data: str, key: bytes) -> bytes:
		"""Gi·∫£i m√£ d·ªØ li·ªáu b·∫±ng AES-128-GCM."""
		raw = b64_to_bytes(base64_data)
		iv = raw[:16]
		aad = raw[16:32]
		ciphertext = raw[32:-16]
		tag = raw[-16:]

		cipher = AES.new(key, AES.MODE_GCM, nonce=iv)
		cipher.update(aad)
		plaintext = cipher.decrypt_and_verify(ciphertext, tag)
		return plaintext

	def decrypt_and_decompress(enc_base64: str, key_base64: str) -> str:
		"""Gi·∫£i m√£ v√† gi·∫£i n√©n d·ªØ li·ªáu t·ª´ Zalo WebSocket."""
		try:
			key = b64_to_bytes(key_base64)
			decrypted_bytes = decrypt_aes_128_gcm(enc_base64, key)
			with gzip.GzipFile(fileobj=BytesIO(decrypted_bytes)) as f:
				decompressed = f.read()
			return decompressed.decode('utf-8')
		except Exception as e:
			return f"‚ùå Decrypt failed: {e}"