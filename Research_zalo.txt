- Với web thì dò websocket -> hàm open websocket -> ra listener message -> dò ra _onRawData -> _onData để xử lý message sau khi đã decrypt và hàm decrypt -> đưa vào chatgpt để generate ra code decrypt với key được tạo ra ở mỗi session

- Với zalo window app thì nó đang được build bằng electron -> web-based app -> unpackaged ra đặt tên folder là app, move app.asar qua chỗ khác, tạo 1 file app.asar khác với nội dung là :echo "{}" -> để nó fallback về folder app (do trong logic của Zalo.exe sẽ check xem app.asar có hay không) -> sau đó xài JS-Beautify for VS Code extension (ấn F1 -> beautify) để generate ra code dễ đọc hơn

- Flow tìm thì từ việc open WebSocket -> dò ra các listener liên quan -> dò ra hàm sử dụng để decrypt

- Hàm xử lý undo trong database và tin nhắn mới nhận tới

- beautify bằng js-beautify : Get-ChildItem .\ -Recurse -Filter *.js | ForEach-Object { js-beautify $_.FullName -r }

- replace bằng git grep: git grep -l 'devTools: !1' | xargs sed -i 's/devTools: !1/devTools: true/g'

- debug UI electron: Zalo.exe --remote-debugging-port=9222
- debug main.js electron : Zalo.exe --inspect=9229
-> Zalo.exe --inspect=9229 --remote-debugging-port=9222
edge://inspect/#devices
chrome://inspect/#devices

- đem console.log về:
	const iframe = document.createElement('iframe');
	iframe.style.display = 'none';
	document.body.appendChild(iframe);

	// Gán lại console.log từ iframe
	console.log = iframe.contentWindow.console.log.bind(window);

- string to json: JSON.parse()

undoMessage(t) {
	const n = T.default.getInstance();
	return new Promise(((a, s) => {
		const {
			toUid: i,
			fromUid: o,
			cliMsgId: r
		} = t;
		let c = t.msgId;
		this.getMessagesInTransaction(c, r + "", i, o, t.key).then((r => {
			const {
				msgIds: d = [],
				msg: A = null
			} = r || {};
			if (A) {
				J.zsymb(3, "N3_PRM", ["{} [undoMessage] found msg for {}", "v0t3oH"], ae, c), c = A.msgId;
				const r = t.cliMsgId + "",
					d = {
						fromUid: o,
						msgId: c,
						cliMsgId: r,
						toUid: i
					},
					h = e => -1 != o ? !!Object(x.a)(e, d) || this.isQuoteEqual(e, d) : e.msgId === c || e.quote && e.quote.globalMsgId + "" === c || e.quote && r && e.quote.cliMsgId === r,
					m = (t, s) => {
						for (let a of t) {
							if (a.msgId === c) {
								if (this.deleteMessageResourceIfExists(a), this.FileUtils && a.msgType === u.MSG_FILE && a.message && a.message.href) {
									let e = this.FileUtils.getDownloadKey(a);
									this.FileUtils.cancelDownload(e)
								}
								a.msgType = u.MSG_UNDO, a.originMsgType = "chat.undo", "0" !== a.fromUid && (a = v.default.convertToRecalled(a)), Object(L.f)(a) !== u.MSG_E2EE_PENDING && Object(L.f)(a) !== u.MSG_E2EE_FAILED || (a.e2eeStatus = u.MSG_E2EE_UNDO);
								if (E.a.getInstance().deleteMessage(a.msgId, a), Object(H.a)()) {
									let t = "unknown";
									Object(K.isPhotoOrVideoMessage)(a) ? t = "image" : Object(K.isFileMessage)(a) ? t = "file" : Object(K.isLinkMessage)(a) && (t = "link"), U.ModuleContainer.resolve(j.a).deleteMediasById(t, a.toUid, {
										newId: a ? `${a.cliMsgId}_${a.fromUid}_${a.toUid}` : void 0,
										oldId: a.msgId
									}).catch((t => {
										J.zsymb(21, "2i40xJ", ["{} [handleUndoMessage] delete media err: {}", "xF7liU"], ae, e)
									}))
								} else {
									const e = [n.Core.Image, n.Core.File, n.Core.Link, n.Core.Notifications];
									for (let t = 0; t < e.length; t++) e[t].delete(c).catch((n => {
										this._pendingActions(n, e[t].name, "delete", [c])
									}))
								}
								if (a.staredDttm) {
									const e = async ({
										msgId: e,
										staredDttm: t
									}, n = T.default.getInstance().Core.StarMessage) => {
										const a = l.default.getTsStarMsgSchemaChanged();
										if (t && t >= a) n.delete(e);
										else {
											let t = e;
											await n.get(e) || (t = parseInt(e)), n.delete(t)
										}
									};
									e({
										msgId: a.msgId,
										staredDttm: a.staredDttm
									}, n.Core.StarMessage).catch((e => {
										J.zsymb(21, "ivrKOq", ["{} [handleDeleteEveryone] delete star msg in store err: {}", "SiNuwb"], ae, e)
									})), delete a.staredDttm
								}
								n.Core.Mention.delete(parseInt(c)).catch((e => {
									this._pendingActions(e, n.Core.Mention.name, "delete", [parseInt(c)])
								}));
								let t = a.sendDttm;
								n.Core.Notifications.delete(parseInt(t)).catch((e => {
									this._pendingActions(e, n.Core.Notifications.name, "delete", [parseInt(t)])
								})), s = a
							} else this.isQuoteEqual(a, s) && (a.quote.cliMsgType = u.MSG_UNDO, a.quote.msg = "[Tin nhắn đã được thu hồi]");
							const t = q.a.now();
							n.Core.Message.insert(a, {
								replace: !0
							}).catch((e => {
								this._pendingActions(e, n.Core.Message.name, "insert", [a, {
									replace: !0
								}])
							})).then((() => {
								Object(Y.b)().logInfo(Y.a.StoreMessage, {
									duration: q.a.now() - t,
									action_name: "replaceMsg",
									message_size: 1
								})
							}))
						}
						return a(s), s
					},
					g = e => {
						const t = {
								from: [i, e.sendDttm, e.msgId],
								to: [i, $, Z],
								excludeFrom: !1,
								excludeTo: !1
							},
							a = {
								index: "userId_sendDttm_msgId",
								direction: R.c.NEXT,
								limit: 500,
								partition: i,
								useLGKeyRange: !0
							};
						n.Core.Message.getAll(t, a).then((t => {
							let n = [];
							if (t && t.length)
								for (let e of t) e && h(e) && n.push(e);
							return m(n, e)
						})).catch(s)
					};
				g(A), A.msgId && this.previewDataManager.onUndoMessage("server", A)
			} else J.zsymb(3, "juHYXU", ["{} [undoMessage] cant find msg for {}", "tdEe3a"], ae, c), s("invalid msg")
		})).catch((e => {
			J.zsymb(3, "rPkEXz", ["{} [undoMessage] find msg for {} err: {}", "NEyXw_"], ae, c, e), s(e)
		}))
	}))
}